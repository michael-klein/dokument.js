{"version":3,"file":"dokument.js.cjs.production.min.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/utils/file_utils.ts","../src/utils/document_provider.ts","../src/store/docStore.ts","../src/search/search_index.ts","../src/doc_context.ts","../src/hooks/use_doc_context.ts","../src/components/docs.tsx","../src/store/hooks/use_doc_store.ts","../src/components/document_renderer.tsx","../src/components/main.tsx","../src/hooks/use_to.ts","../src/components/search.tsx","../src/components/component_list_value.ts","../src/store/hooks/use_document.ts","../src/components/nav.tsx","../src/components/sidebar.tsx","../src/components/previous_and_next.tsx","../src/index.tsx"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && !check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, value);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\t_entry(_this).then(returnValue, function(error) {\n\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import ky from 'ky';\n\nexport function join(...args: string[]): string {\n  let parts: string[] = [];\n  for (let i: number = 0, l = args.length; i < l; i++) {\n    parts = parts.concat(args[i].split('/'));\n  }\n  let newParts: string[] = [];\n  for (let i: number = 0, l = parts.length; i < l; i++) {\n    let part: string = parts[i];\n    if (!part || part === '.') continue;\n    if (part === '..') newParts.pop();\n    else newParts.push(part);\n  }\n  if (parts[0] === '') newParts.unshift('');\n  return newParts.join('/') || (newParts.length ? '/' : '.');\n}\n\nexport async function getFile(filePath: string): Promise<string> {\n  return ky.get(filePath).text();\n}\n\nexport async function getJSON<T extends Object = JSON>(\n  filePath: string\n): Promise<T> {\n  return ky.get(filePath).json();\n}\n","import { getFile, getJSON, join } from './file_utils';\nimport removeMarkdown from 'remove-markdown';\n\nexport interface DocumentProvider {\n  getDocument(id: string): string;\n  getDocumentMap(): DocumentMap;\n}\n\nexport interface NavbarJSON {\n  [key: string]: string | NavbarJSON;\n}\n\nexport enum NavbarItemType {\n  CATEGORY,\n  DOCUMENT,\n}\nexport interface NavbarItem {\n  type: NavbarItemType;\n  path?: string;\n  slug?: string;\n  children?: Navbar;\n}\n\nexport interface Navbar {\n  [title: string]: NavbarItem;\n}\n\nexport interface DocumentHeading {\n  size: number;\n  text: string;\n  raw: string;\n  slug: string;\n}\nexport interface DocumentData {\n  title: string;\n  path: string;\n  slug: string;\n  content: string;\n  headings: DocumentHeading[];\n}\nexport interface DocumentMap {\n  [slug: string]: DocumentData;\n}\n\nexport function findHeadings(document: string): DocumentHeading[] {\n  const parts: string[] = document.split(/\\n/g);\n  const headings: DocumentHeading[] = [];\n  let i: number = 0;\n  for (const part of parts) {\n    if (part.trim()[0] === '#') {\n      let size: number = 1;\n      while (part[size] && part[size] === '#') {\n        size++;\n      }\n      let text: string = removeMarkdown(part);\n      text = text.trim();\n      headings.push({\n        size,\n        text,\n        raw: part,\n        slug: `${i}-${slugify(text)}`,\n      });\n      i++;\n    }\n  }\n  return headings;\n}\n\nexport function buildNavbar(navbarJSON: NavbarJSON): Navbar {\n  let navbar: Navbar = {};\n  for (const title of Object.keys(navbarJSON)) {\n    const entry: string | NavbarJSON = navbarJSON[title];\n    if (typeof entry === 'object') {\n      navbar[title] = {\n        type: NavbarItemType.CATEGORY,\n        children: buildNavbar(entry),\n      };\n    } else {\n      const slug: string = slugify(entry);\n      navbar[title] = {\n        type: NavbarItemType.DOCUMENT,\n        slug: slug,\n        path: entry,\n      };\n    }\n  }\n  return navbar;\n}\n\nexport async function fetchNavbar(path: string): Promise<Navbar> {\n  const navbarJSON: NavbarJSON = await getJSON<NavbarJSON>(\n    join(path, 'navbar.docs.json')\n  );\n  return buildNavbar(navbarJSON);\n}\n\nexport function slugify(path: string): string {\n  const a =\n    'àáâäæãåāăąçćčđďèéêëēėęěğǵḧîïíīįìłḿñńǹňôöòóœøōõṕŕřßśšşșťțûüùúūǘůűųẃẍÿýžźż·/_,:;';\n  const b =\n    'aaaaaaaaaacccddeeeeeeeegghiiiiiilmnnnnooooooooprrsssssttuuuuuuuuuwxyyzzz------';\n  const p = new RegExp(a.split('').join('|'), 'g');\n\n  return path\n    .toString()\n    .toLowerCase()\n    .replace(/.mdx/g, '')\n    .replace(/\\s+/g, '-')\n    .replace(p, c => b.charAt(a.indexOf(c)))\n    .replace(/&/g, '-and-')\n    .replace(/[^\\w\\-]+/g, '')\n    .replace(/\\-\\-+/g, '-')\n    .replace(/^-+/, '')\n    .replace(/-+$/, '');\n}\n\nexport async function fetchDocuments(\n  rootPath: string,\n  navbar: Navbar\n): Promise<DocumentMap> {\n  let documentMap: DocumentMap = {};\n\n  for (const title of Object.keys(navbar)) {\n    const { slug, children, type, path } = navbar[title];\n    if (type === NavbarItemType.CATEGORY) {\n      const subResult: DocumentMap = await fetchDocuments(rootPath, children);\n      documentMap = { ...documentMap, ...subResult };\n    } else {\n      const docPath: string = join(rootPath, path);\n      const content: string = await getFile(docPath);\n      documentMap[slug] = {\n        title,\n        content,\n        path: docPath,\n        slug,\n        headings: findHeadings(content),\n      };\n    }\n  }\n\n  return documentMap;\n}\n","import { Store } from 'pullstate';\nimport {\n  Navbar,\n  fetchNavbar,\n  DocumentMap,\n  fetchDocuments,\n  DocumentData,\n} from '../utils/document_provider';\n\nexport interface DocStoreState {\n  navbar?: Navbar;\n  documentMap: DocumentMap;\n  documentsLoaded: boolean;\n}\n\nexport const docStore = new Store<DocStoreState>({\n  documentMap: {},\n  documentsLoaded: false,\n});\n\nexport const docStoreActions = {\n  async loadNavbar(path: string) {\n    const navbar = await fetchNavbar(path);\n    docStore.update(state => {\n      state.navbar = navbar;\n    });\n  },\n\n  async loadDocuments(rootPath: string, navbar: Navbar) {\n    const documentMap = await fetchDocuments(rootPath, navbar);\n    docStore.update(state => {\n      state.documentMap = { ...state.documentMap, ...documentMap };\n      state.documentsLoaded = true;\n    });\n  },\n\n  async getSaveDocumentByNavId(slug?: string): Promise<DocumentData> {\n    let document: DocumentData = docStore.getRawState().documentMap[slug];\n    if (!document) {\n      document = await new Promise(resolve => {\n        let unsubscribe = docStore.subscribe(\n          state => state.documentMap,\n          documentMap => {\n            if (!slug) {\n              slug = Object.keys(documentMap)[0];\n            }\n            if (documentMap[slug]) {\n              resolve(documentMap[slug]);\n              unsubscribe();\n            }\n          }\n        );\n      });\n    }\n    return document;\n  },\n\n  async getNavbar(): Promise<Navbar> {\n    let navbar: Navbar = docStore.getRawState().navbar;\n    if (!navbar) {\n      navbar = await new Promise(resolve => {\n        let unsubscribe = docStore.subscribe(\n          state => state.navbar,\n          navbar => {\n            if (navbar) {\n              resolve(navbar);\n              unsubscribe();\n            }\n          }\n        );\n      });\n    }\n    return navbar;\n  },\n};\n","import elasticlunr from 'elasticlunr';\nimport { DocumentData } from '../utils/document_provider';\n\nconst index: any = elasticlunr(function(this: any): void {\n  this.addField('title');\n  this.addField('content');\n  this.setRef('id');\n  this.saveDocument(true);\n});\n\nexport function addDocumentToIndex(doc: DocumentData): void {\n  index.addDoc({\n    id: doc.slug,\n    title: doc.title,\n    content: doc.content,\n  });\n}\n\nexport interface DocSearchResult {\n  slug: string;\n  score: number;\n}\nexport function search(query: string): DocSearchResult[] {\n  return index\n    .search(query, { title: { boost: 2 }, content: { boost: 1 } })\n    .map((result: any) => {\n      return {\n        slug: result.ref,\n        score: result.score,\n      };\n    });\n}\n","import * as React from 'react';\nimport { docStore, DocStoreState } from './store/docStore';\nimport { Store } from 'pullstate';\nimport { ComponentList } from './components/component_list';\nimport { search, DocSearchResult } from './search/search_index';\n\nexport interface DocContextValue {\n  docStore: Store<DocStoreState>;\n  remarkPlugins: Function[];\n  rehypePlugins: Function[];\n  rootPath: string;\n  componentList: ComponentList;\n  search: (query: string) => DocSearchResult[];\n}\nexport const docContextValue: DocContextValue = {\n  docStore,\n  remarkPlugins: [],\n  rehypePlugins: [],\n  rootPath: './',\n  componentList: undefined,\n  search: search,\n};\n\nexport const docContext = React.createContext(docContextValue);\n","import * as React from 'react';\nimport { docContext } from '../doc_context';\n\nexport function useDocContext() {\n  return React.useContext(docContext);\n}\n","import * as React from 'react';\nimport { useDocContext } from '../hooks/use_doc_context';\nimport { HashRouter } from 'react-router-dom';\n\nexport function Docs(): JSX.Element {\n  const { SideBar, Main } = useDocContext().componentList;\n  return (\n    <div className=\"docs\">\n      <HashRouter>\n        <SideBar></SideBar>\n        <Main></Main>\n      </HashRouter>\n    </div>\n  );\n}\n","import { docStore, DocStoreState } from '../../store/docStore';\nimport { useStoreState } from 'pullstate';\n\nexport function useDocStore<SS = any>(\n  getSubState: (state: DocStoreState) => SS\n): SS {\n  return useStoreState(docStore, getSubState);\n}\n","import * as React from 'react';\n\n// tslint:disable\nimport MDX from '@mdx-js/runtime';\nimport { useSaveDocumentByNavId } from '../store/hooks/use_document';\nimport { useDocContext } from '../hooks/use_doc_context';\nimport { DocumentData } from '../utils/document_provider';\nimport { Link } from 'react-router-dom';\nimport innerText from 'react-innertext';\nimport { useDocStore } from '../store/hooks/use_doc_store';\n\nexport interface MDXContext {\n  currentDocument?: DocumentData;\n}\nlet hCount: number = 0;\nexport const mdxContext: React.Context<MDXContext> = React.createContext({});\nconst components: { [key: string]: React.FunctionComponent } = {\n  Demo: () => <h1>This is a demo component</h1>,\n};\n['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].forEach(h => {\n  components[h] = (props: any) => {\n    const { currentDocument } = React.useContext(mdxContext);\n    let check = props.children;\n    if (check instanceof Array) {\n      check = React.createElement('div', { children: props.children });\n    }\n    const text: string = React.isValidElement(check)\n      ? innerText(check)\n      : props.children;\n    const heading = currentDocument.headings.find(heading =>\n      text.toString().includes(heading.text)\n    );\n    return React.createElement(h, {\n      key: h + hCount++,\n      id: heading && heading.slug,\n      children: [\n        <>\n          {heading ? (\n            <Link to={`${heading.slug}`}>{heading.text}</Link>\n          ) : (\n            props.children\n          )}\n        </>,\n      ],\n    });\n  };\n});\n\nexport function DocumentRenderer(props: {\n  slug: string;\n  headingSlug: string;\n}): JSX.Element {\n  const { rehypePlugins, remarkPlugins, componentList } = useDocContext();\n  const { PreviousAndNext } = componentList;\n  const Provider = mdxContext.Provider;\n\n  const currentDocument = useSaveDocumentByNavId(props.slug);\n  React.useEffect(() => {\n    const heading: HTMLElement = document.getElementById(props.headingSlug);\n    if (heading) {\n      heading.scrollIntoView({ behavior: 'smooth' });\n    }\n  }, [props.headingSlug, currentDocument]);\n\n  const documentMap = useDocStore(state => state.documentMap);\n\n  let previous: DocumentData;\n  let next: DocumentData;\n  if (currentDocument) {\n    const slugs: string[] = Object.keys(documentMap);\n    const docIndex: number = slugs.indexOf(currentDocument.slug);\n    if (docIndex > 0) {\n      previous = documentMap[slugs[docIndex - 1]];\n    }\n    if (docIndex < slugs.length - 1) {\n      next = documentMap[slugs[docIndex + 1]];\n    }\n  }\n  return currentDocument ? (\n    <Provider value={{ currentDocument }}>\n      <PreviousAndNext previous={previous} next={next}></PreviousAndNext>\n      <div>\n        <MDX\n          components={components}\n          remarkPlugins={remarkPlugins}\n          rehypePlugins={rehypePlugins}\n        >\n          {currentDocument.content}\n        </MDX>\n      </div>\n      <PreviousAndNext previous={previous} next={next}></PreviousAndNext>\n    </Provider>\n  ) : (\n    <div>loading document...</div>\n  );\n}\n","import * as React from 'react';\nimport { useDocContext } from '../hooks/use_doc_context';\nimport { Switch, Route, useParams } from 'react-router';\nfunction RenderArticle() {\n  const { DocumentRenderer } = useDocContext().componentList;\n  let { slug, headingSlug } = useParams();\n  return (\n    <DocumentRenderer slug={slug} headingSlug={headingSlug}></DocumentRenderer>\n  );\n}\n\nexport function Main(): JSX.Element {\n  return (\n    <main>\n      <article>\n        <Switch>\n          <Route path={`/document/:slug/:headingSlug?`}>\n            <RenderArticle></RenderArticle>\n          </Route>\n        </Switch>\n      </article>\n    </main>\n  );\n}\n","import { DocumentData, DocumentHeading } from '../utils/document_provider';\nimport { join } from '../utils/file_utils';\nimport { useDocContext } from './use_doc_context';\n\nexport function useGetTo(): (doc: DocumentData) => string {\n  const { rootPath } = useDocContext();\n  return doc => {\n    const topHeading: DocumentHeading =\n      doc && doc.headings[0] && doc.headings[0].size === 1\n        ? doc.headings[0]\n        : undefined;\n    return join(\n      '/document',\n      rootPath,\n      doc.slug,\n      topHeading ? topHeading.slug : ''\n    );\n  };\n}\n","import * as React from 'react';\nimport { useDocContext } from '../hooks/use_doc_context';\nimport { useDocStore } from '../store/hooks/use_doc_store';\nimport removeMarkdown from 'remove-markdown';\nimport Highlighter from 'react-highlight-words';\nimport { Link, useLocation } from 'react-router-dom';\nimport { useGetTo } from '../hooks/use_to';\n\nfunction getSentencesWithSearchResults(\n  text: string,\n  searchWords: string[]\n): string[] {\n  return text.split(/[.?!\\n]/).filter(function(n) {\n    return new RegExp(`${searchWords.join('|')}`, 'i').test(n);\n  });\n}\n\nexport function SearchResults(props: { searchQuery: string }): JSX.Element {\n  const { searchQuery } = props;\n  const { search } = useDocContext();\n  const documentMap = useDocStore(state => state.documentMap);\n  const result = search(searchQuery);\n  const getTo = useGetTo();\n  return (\n    <div className={'search-results'}>\n      <h1>\n        Listing {result.length} document{result.length !== 1 ? 's' : ''} with\n        search results for {searchQuery}:\n      </h1>\n      <ul>\n        {result.map(r => {\n          const doc = documentMap[r.slug];\n          return (\n            <li key={doc.slug}>\n              <label>\n                <Link to={getTo(doc)}>\n                  <Highlighter\n                    highlightClassName=\"search-highlight\"\n                    searchWords={[searchQuery]}\n                    autoEscape={true}\n                    textToHighlight={doc.title}\n                  />\n                </Link>\n              </label>\n              {getSentencesWithSearchResults(removeMarkdown(doc.content), [\n                searchQuery,\n              ]).map(item => (\n                <pre key={item}>\n                  <Highlighter\n                    highlightClassName=\"search-highlight\"\n                    searchWords={[searchQuery]}\n                    autoEscape={true}\n                    textToHighlight={item}\n                  />\n                </pre>\n              ))}\n            </li>\n          );\n        })}\n      </ul>\n    </div>\n  );\n}\n\nexport function Search(): JSX.Element {\n  const [searchQuery, setSearchQuery] = React.useState('');\n  const location = useLocation();\n  React.useEffect(() => {\n    setSearchQuery('');\n  }, [location]);\n  React.useEffect(() => {\n    const listener: (event: MouseEvent) => void = event => {\n      console.log(event);\n      let target: HTMLElement = event.target as HTMLElement;\n      while (target !== document.body) {\n        if (target instanceof HTMLAnchorElement) {\n          if (\n            target.href.replace(\n              window.location.href.replace(window.location.hash, ''),\n              ''\n            )[0] === '#'\n          ) {\n            setSearchQuery('');\n            return;\n          }\n        }\n        target = target.parentElement;\n      }\n    };\n    document.body.addEventListener('click', listener);\n    return () => {\n      document.body.removeEventListener('click', listener);\n    };\n  }, []);\n  return (\n    <div className=\"search\">\n      {searchQuery.length > 0 && (\n        <SearchResults searchQuery={searchQuery}></SearchResults>\n      )}\n      <input\n        type=\"text\"\n        value={searchQuery}\n        placeholder=\"search...\"\n        onChange={(e: React.SyntheticEvent<HTMLInputElement>) =>\n          setSearchQuery(e.currentTarget.value)\n        }\n      ></input>\n    </div>\n  );\n}\n","import { ComponentList } from './component_list';\nimport { DocumentRenderer } from './document_renderer';\nimport { NavItem, NavLevel, Nav } from './nav';\nimport { SideBar } from './sidebar';\nimport { Main } from './main';\nimport { Search } from './search';\nimport { PreviousAndNext } from './previous_and_next';\n\nexport const componentListValue: ComponentList = {\n  DocumentRenderer,\n  NavItem,\n  NavLevel,\n  Nav,\n  SideBar,\n  Main,\n  Search,\n  PreviousAndNext,\n};\n","import * as React from 'react';\nimport { DocumentData } from '../../utils/document_provider';\nimport { docStoreActions, docStore } from '../docStore';\n\nexport function useSaveDocumentByNavId(id: string = ''): DocumentData {\n  const documentMap = docStore.getRawState().documentMap;\n  const [reRenderCount, setReRenderCount] = React.useState(0);\n  const docRef = React.useRef(documentMap[id]);\n  docRef.current = documentMap[id];\n  React.useEffect(() => {\n    if (!docRef.current) {\n      docStoreActions.getSaveDocumentByNavId(id).then(document => {\n        docRef.current = document;\n        setReRenderCount(reRenderCount + 1);\n      });\n    }\n  }, []);\n  return docRef.current;\n}\n","import * as React from 'react';\nimport { Link } from 'react-router-dom';\nimport {\n  Navbar,\n  NavbarItemType,\n  DocumentHeading,\n} from '../utils/document_provider';\nimport { useDocStore } from '../store/hooks/use_doc_store';\nimport { useDocContext } from '../hooks/use_doc_context';\n\nexport function NavItem(props: {\n  path: string;\n  slug?: string;\n  children: React.ReactNode;\n}): JSX.Element {\n  const documentMap = useDocStore(state => state.documentMap);\n  const document = documentMap[props.slug];\n  const topHeading: DocumentHeading =\n    document && document.headings[0] && document.headings[0].size === 1\n      ? document.headings[0]\n      : undefined;\n  return (\n    <li className=\"nav-item link\">\n      <Link to={`${props.path}${topHeading ? `/${topHeading.slug}` : ``}`}>\n        {topHeading ? topHeading.text : props.children}\n      </Link>\n      {document && (\n        <ul className=\"nav\">\n          {document.headings\n            .filter(\n              (heading: DocumentHeading, index: number) =>\n                heading.size < 4 && (index > 0 || heading.size > 1)\n            )\n            .map(heading => {\n              return (\n                <NavItem\n                  key={heading.raw}\n                  path={`${props.path}/${heading.slug}`}\n                >\n                  {heading.text}\n                </NavItem>\n              );\n            })}\n        </ul>\n      )}\n    </li>\n  );\n}\n\nexport function NavLevel(props: { navbar: Navbar }): JSX.Element {\n  const { navbar } = props;\n  const { NavItem, NavLevel } = useDocContext().componentList;\n  return (\n    <ul className=\"nav\">\n      {Object.keys(navbar).map(title => {\n        const { type, children, slug } = navbar[title];\n        if (type === NavbarItemType.CATEGORY) {\n          return (\n            <li className=\"nav-item sub-nav\" key={slug + type}>\n              <div className=\"nav-category\">{title}</div>\n              <NavLevel {...{ navbar: children }}></NavLevel>\n            </li>\n          );\n        } else {\n          return (\n            <NavItem key={slug + type} path={'/document/' + slug} slug={slug}>\n              {title}\n            </NavItem>\n          );\n        }\n      })}\n    </ul>\n  );\n}\n\nexport function Nav(): JSX.Element {\n  const [documentsLoaded, navbar] = useDocStore(state => [\n    state.documentsLoaded,\n    state.navbar,\n  ]);\n  const { NavLevel } = useDocContext().componentList;\n  return !documentsLoaded ? (\n    <div>loading navbar...</div>\n  ) : (\n    <nav>\n      <NavLevel {...{ navbar }}></NavLevel>\n    </nav>\n  );\n}\n","import * as React from 'react';\nimport { useDocContext } from '../hooks/use_doc_context';\n\nexport function SideBar(): JSX.Element {\n  const { Nav, Search } = useDocContext().componentList;\n  return (\n    <aside className=\"sidebar\">\n      <h1>Dokument.js</h1>\n      <Search></Search>\n      <Nav></Nav>\n    </aside>\n  );\n}\n","import * as React from 'react';\nimport { DocumentData } from '../utils/document_provider';\nimport { useGetTo } from '../hooks/use_to';\nimport { Link } from 'react-router-dom';\nexport interface PreviousAndNextProps {\n  previous?: DocumentData;\n  next?: DocumentData;\n}\nexport function PreviousAndNext(props: PreviousAndNextProps): JSX.Element {\n  const { previous, next } = props;\n  const getTo = useGetTo();\n  return (\n    <div className=\"previous-next\">\n      {previous && (\n        <div className=\"previous\">\n          <span>\n            <Link to={getTo(previous)}>{previous.title}</Link>\n          </span>\n        </div>\n      )}\n      {next && (\n        <div className=\"next\">\n          <span>\n            <Link to={getTo(next)}>{next.title}</Link>\n          </span>\n        </div>\n      )}\n    </div>\n  );\n}\n","import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport '@babel/polyfill';\nimport { Docs } from './components/docs';\nimport { docStore, docStoreActions } from './store/docStore';\nimport { docContext, docContextValue } from './doc_context';\nimport { ComponentList } from './components/component_list';\nimport { componentListValue } from './components/component_list_value';\nimport { addDocumentToIndex } from './search/search_index';\n\nexport interface DocsOptions {\n  rootPath: string;\n  remarkPlugins: Function[];\n  rehypePlugins: Function[];\n  componentList: ComponentList;\n}\n\nasync function load(options: DocsOptions) {\n  await docStoreActions.loadNavbar(options.rootPath);\n  await docStoreActions.loadDocuments(\n    options.rootPath,\n    docStore.getRawState().navbar\n  );\n  Object.values(docStore.getRawState().documentMap).forEach(doc => {\n    addDocumentToIndex(doc);\n  });\n  console.log(docStore);\n}\n\nexport async function docs(\n  container: HTMLElement,\n  optionsIn: Partial<DocsOptions> = {}\n): Promise<void> {\n  const options: DocsOptions = {\n    rootPath: '/',\n    remarkPlugins: [],\n    rehypePlugins: [],\n    ...optionsIn,\n    componentList: {\n      ...componentListValue,\n      ...(optionsIn.componentList || {}),\n    },\n  };\n\n  load(options);\n  const Provider = docContext.Provider;\n  ReactDOM.render(\n    <Provider value={{ ...docContextValue, ...options }}>\n      <Docs></Docs>\n    </Provider>,\n    container\n  );\n}\n"],"names":["_Pact","prototype","then","onFulfilled","onRejected","result","state","this","s","callback","_settle","v","e","o","_this","value","pact","bind","observer","_isSettledPact","thenable","_iteratorSymbol","Symbol","iterator","join","parts","args","i","l","length","concat","split","newParts","part","pop","push","unshift","asyncIterator","NavbarItemType","fetchDocuments","rootPath","navbar","documentMap","target","body","check","step","reject","_cycle","next","done","return","_fixup","TypeError","values","array","_forTo","Object","keys","title","slug","children","type","path","CATEGORY","subResult","docPath","filePath","ky","get","text","getFile","content","headings","findHeadings","document","trim","size","removeMarkdown","raw","slugify","buildNavbar","navbarJSON","entry","DOCUMENT","a","p","RegExp","toString","toLowerCase","replace","c","charAt","indexOf","docStore","Store","documentsLoaded","index","elasticlunr","addField","setRef","saveDocument","docContextValue","remarkPlugins","rehypePlugins","componentList","undefined","search","query","boost","map","ref","score","docContext","React","useDocContext","Docs","Main","className","HashRouter","SideBar","useDocStore","getSubState","useStoreState","hCount","mdxContext","components","Demo","RenderArticle","DocumentRenderer","useParams","headingSlug","useGetTo","doc","topHeading","SearchResults","props","searchQuery","getTo","r","searchWords","key","Link","to","Highlighter","highlightClassName","autoEscape","textToHighlight","filter","n","test","item","forEach","h","currentDocument","Array","innerText","heading","find","includes","id","componentListValue","PreviousAndNext","Provider","getRawState","reRenderCount","setReRenderCount","docRef","current","Promise","resolve","unsubscribe","subscribe","docStoreActions","useSaveDocumentByNavId","getElementById","scrollIntoView","behavior","previous","slugs","docIndex","MDX","NavItem","NavLevel","Nav","Search","Switch","Route","setSearchQuery","location","useLocation","listener","event","console","log","HTMLAnchorElement","href","window","hash","parentElement","addEventListener","removeEventListener","placeholder","onChange","currentTarget","container","optionsIn","options","json","getJSON","fetchNavbar","update","addDoc","addDocumentToIndex","load","ReactDOM"],"mappings":"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"}